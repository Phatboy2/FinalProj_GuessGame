<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="nom, eating data byte by byte"><meta name="keywords" content="rust, rustlang, rust-lang, nom"><title>nom - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../nom/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../nom/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate nom</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 1.2.4</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../nom/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">nom</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/nom/lib.rs.html#1-151">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>nom, eating data byte by byte</p>
<p>nom is a parser combinator library with a focus on safe parsing,
streaming patterns, and as much as possible zero copy.</p>
<p>The code is available on <a href="https://github.com/Geal/nom">Github</a></p>
<h2 id="example"><a href="#example">Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">nom</span>;

<span class="kw">use</span> <span class="ident">nom</span>::{<span class="ident">IResult</span>,<span class="ident">digit</span>};
<span class="kw">use</span> <span class="ident">nom::IResult</span>::<span class="kw-2">*</span>;

<span class="comment">// Parser definition</span>

<span class="kw">use</span> <span class="ident">std::str</span>;
<span class="kw">use</span> <span class="ident">std::str::FromStr</span>;

<span class="macro">named!</span>(<span class="ident">parens</span><span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>, <span class="macro">delimited!</span>(
    <span class="macro">char!</span>(<span class="string">&#39;(&#39;</span>),
    <span class="ident">expr</span>,
    <span class="macro">char!</span>(<span class="string">&#39;)&#39;</span>)
  )
);

<span class="macro">named!</span>(<span class="ident">i64_digit</span><span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
  <span class="macro">map_res!</span>(
    <span class="macro">map_res!</span>(
      <span class="ident">digit</span>,
      <span class="ident">str::from_utf8</span>
    ),
    <span class="ident">FromStr::from_str</span>
  )
);

<span class="comment">// We transform an integer string into a i64</span>
<span class="comment">// we look for a digit suite, and try to convert it.</span>
<span class="comment">// if either str::from_utf8 or FromStr::from_str fail,</span>
<span class="comment">// the parser will fail</span>
<span class="macro">named!</span>(<span class="ident">factor</span><span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
  <span class="macro">alt!</span>(
    <span class="ident">i64_digit</span>
  <span class="op">|</span> <span class="ident">parens</span>
  )
);

<span class="comment">// we define acc as mutable to update its value whenever a new term is found</span>
<span class="macro">named!</span>(<span class="ident">term</span> <span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
  <span class="macro">chain!</span>(
    <span class="kw-2">mut</span> <span class="ident">acc</span>: <span class="ident">factor</span>  ~
             <span class="macro">many0!</span>(
               <span class="macro">alt!</span>(
                 <span class="macro">tap!</span>(<span class="ident">mul</span>: <span class="macro">preceded!</span>(<span class="macro">tag!</span>(<span class="string">&quot;*&quot;</span>), <span class="ident">factor</span>) =&gt; <span class="ident">acc</span> <span class="op">=</span> <span class="ident">acc</span> <span class="op">*</span> <span class="ident">mul</span>) <span class="op">|</span>
                 <span class="macro">tap!</span>(<span class="ident">div</span>: <span class="macro">preceded!</span>(<span class="macro">tag!</span>(<span class="string">&quot;/&quot;</span>), <span class="ident">factor</span>) =&gt; <span class="ident">acc</span> <span class="op">=</span> <span class="ident">acc</span> <span class="op">/</span> <span class="ident">div</span>)
               )
             ),
    <span class="op">|</span><span class="op">|</span> { <span class="kw">return</span> <span class="ident">acc</span> }
  )
);

<span class="macro">named!</span>(<span class="ident">expr</span> <span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
  <span class="macro">chain!</span>(
    <span class="kw-2">mut</span> <span class="ident">acc</span>: <span class="ident">term</span>  ~
             <span class="macro">many0!</span>(
               <span class="macro">alt!</span>(
                 <span class="macro">tap!</span>(<span class="ident">add</span>: <span class="macro">preceded!</span>(<span class="macro">tag!</span>(<span class="string">&quot;+&quot;</span>), <span class="ident">term</span>) =&gt; <span class="ident">acc</span> <span class="op">=</span> <span class="ident">acc</span> <span class="op">+</span> <span class="ident">add</span>) <span class="op">|</span>
                 <span class="macro">tap!</span>(<span class="ident">sub</span>: <span class="macro">preceded!</span>(<span class="macro">tag!</span>(<span class="string">&quot;-&quot;</span>), <span class="ident">term</span>) =&gt; <span class="ident">acc</span> <span class="op">=</span> <span class="ident">acc</span> <span class="op">-</span> <span class="ident">sub</span>)
               )
             ),
    <span class="op">|</span><span class="op">|</span> { <span class="kw">return</span> <span class="ident">acc</span> }
  )
);

<span class="kw">fn</span> <span class="ident">main</span>() {
  <span class="macro">assert_eq!</span>(<span class="ident">expr</span>(<span class="string">b&quot;1+2&quot;</span>),         <span class="ident">IResult::Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">3</span>));
  <span class="macro">assert_eq!</span>(<span class="ident">expr</span>(<span class="string">b&quot;12+6-4+3&quot;</span>),    <span class="ident">IResult::Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">17</span>));
  <span class="macro">assert_eq!</span>(<span class="ident">expr</span>(<span class="string">b&quot;1+2*3+4&quot;</span>),     <span class="ident">IResult::Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">11</span>));

  <span class="macro">assert_eq!</span>(<span class="ident">expr</span>(<span class="string">b&quot;(2)&quot;</span>),         <span class="ident">IResult::Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">2</span>));
  <span class="macro">assert_eq!</span>(<span class="ident">expr</span>(<span class="string">b&quot;2*(3+4)&quot;</span>),     <span class="ident">IResult::Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">14</span>));
  <span class="macro">assert_eq!</span>(<span class="ident">expr</span>(<span class="string">b&quot;2*2/(5-1)+3&quot;</span>), <span class="ident">IResult::Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">4</span>));
}</code></pre></div>
</div></details><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.add_error.html" title="nom::add_error macro">add_error</a></div><div class="item-right docblock-short"><p>Add an error if the child parser fails</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.alt.html" title="nom::alt macro">alt</a></div><div class="item-right docblock-short"><p><code>alt!(I -&gt; IResult&lt;I,O&gt; | I -&gt; IResult&lt;I,O&gt; | ... | I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
try a list of parsers, return the result of the first successful one</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.alt_complete.html" title="nom::alt_complete macro">alt_complete</a></div><div class="item-right docblock-short"><p>This is a combination of the <code>alt!</code> and <code>complete!</code> combinators. Rather
than returning <code>Incomplete</code> on partial input, <code>alt_complete!</code> will try the
next alternative in the chain. You should use this only if you know you
will not receive partial input for the rules you’re trying to match (this
is almost always the case for parsing programming languages).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.apply.html" title="nom::apply macro">apply</a></div><div class="item-right docblock-short"><p>emulate function currying: <code>apply!(my_function, arg1, arg2, ...)</code> becomes <code>my_function(input, arg1, arg2, ...)</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.apply_m.html" title="nom::apply_m macro">apply_m</a></div><div class="item-right docblock-short"><p>emulate function currying for method calls on structs 
<code>apply!(self.my_function, arg1, arg2, ...)</code> becomes <code>self.my_function(input, arg1, arg2, ...)</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.bits.html" title="nom::bits macro">bits</a></div><div class="item-right docblock-short"><p><code>bits!( parser ) =&gt; ( &amp;[u8], (&amp;[u8], usize) -&gt; IResult&lt;(&amp;[u8], usize), T&gt; ) -&gt; IResult&lt;&amp;[u8], T&gt;</code>
transforms its byte slice input into a bit stream for the underlying parsers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.call.html" title="nom::call macro">call</a></div><div class="item-right docblock-short"><p>Used to wrap common expressions and function as macros</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.call_m.html" title="nom::call_m macro">call_m</a></div><div class="item-right docblock-short"><p>Used to called methods then move self back into self</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.chain.html" title="nom::chain macro">chain</a></div><div class="item-right docblock-short"><p><code>chain!(I-&gt;IResult&lt;I,A&gt; ~ I-&gt;IResult&lt;I,B&gt; ~ ... I-&gt;IResult&lt;I,X&gt; , || { return O } ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
chains parsers and assemble the results through a closure</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.char.html" title="nom::char macro">char</a></div><div class="item-right docblock-short"><p>matches one character: `char!(char) =&gt; &amp;<a href="https://doc.rust-lang.org/1.63.0/std/primitive.u8.html" title="u8">u8</a> -&gt; IResult&lt;&amp;<a href="https://doc.rust-lang.org/1.63.0/std/primitive.u8.html" title="u8">u8</a>, char&gt;</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.closure.html" title="nom::closure macro">closure</a></div><div class="item-right docblock-short"><p>Wraps a parser in a closure</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.complete.html" title="nom::complete macro">complete</a></div><div class="item-right docblock-short"><p>replaces a <code>Incomplete</code> returned by the child parser
with an <code>Error</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.cond.html" title="nom::cond macro">cond</a></div><div class="item-right docblock-short"><p><code>cond!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.cond_reduce.html" title="nom::cond_reduce macro">cond_reduce</a></div><div class="item-right docblock-short"><p><code>cond_reduce!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
Conditional combinator with error</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.cond_with_error.html" title="nom::cond_with_error macro">cond_with_error</a></div><div class="item-right docblock-short"><p><code>cond_with_error!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.consumer_from_parser.html" title="nom::consumer_from_parser macro">consumer_from_parser</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.count.html" title="nom::count macro">count</a></div><div class="item-right docblock-short"><p><code>count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the child parser a specified number of times</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.count_fixed.html" title="nom::count_fixed macro">count_fixed</a></div><div class="item-right docblock-short"><p><code>count_fixed!(O, I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, [O; nb]&gt;</code>
Applies the child parser a fixed number of times and returns a fixed size array
The type must be specified and it must be <code>Copy</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.dbg.html" title="nom::dbg macro">dbg</a></div><div class="item-right docblock-short"><p>Prints a message if the parser fails</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.dbg_dmp.html" title="nom::dbg_dmp macro">dbg_dmp</a></div><div class="item-right docblock-short"><p>Prints a message and the input if the parser fails</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.delimited.html" title="nom::delimited macro">delimited</a></div><div class="item-right docblock-short"><p><code>delimited!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,U&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
delimited(opening, X, closing) returns X</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.error.html" title="nom::error macro">error</a></div><div class="item-right docblock-short"><p>Prevents backtracking if the child parser fails</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.escaped.html" title="nom::escaped macro">escaped</a></div><div class="item-right docblock-short"><p><code>escaped!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
matches a byte string with escaped characters.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.escaped_transform.html" title="nom::escaped_transform macro">escaped_transform</a></div><div class="item-right docblock-short"><p><code>escaped_transform!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], Vec&lt;T&gt;&gt;</code>
matches a byte string with escaped characters.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.expr_opt.html" title="nom::expr_opt macro">expr_opt</a></div><div class="item-right docblock-short"><p><code>expr_opt!(Option&lt;O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Option<T> and returns a IResult::Done(I,T) if Some</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.expr_res.html" title="nom::expr_res macro">expr_res</a></div><div class="item-right docblock-short"><p><code>expr_res!(Result&lt;E,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Result&lt;T,E&gt; and returns a IResult::Done(I,T) if Ok</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.fix_error.html" title="nom::fix_error macro">fix_error</a></div><div class="item-right docblock-short"><p>translate parser result from IResult&lt;I,O,u32&gt; to IResult&lt;I,O,E&gt; with a custom type</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.flat_map.html" title="nom::flat_map macro">flat_map</a></div><div class="item-right docblock-short"><p><code>flat_map!(R -&gt; IResult&lt;R,S&gt;, S -&gt; IResult&lt;S,T&gt;) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.fold_many0.html" title="nom::fold_many0 macro">fold_many0</a></div><div class="item-right docblock-short"><p><code>fold_many0!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 0 or more times and folds the list of return values</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.fold_many1.html" title="nom::fold_many1 macro">fold_many1</a></div><div class="item-right docblock-short"><p><code>fold_many1!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 1 or more times and folds the list of return values</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.fold_many_m_n.html" title="nom::fold_many_m_n macro">fold_many_m_n</a></div><div class="item-right docblock-short"><p><code>fold_many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser between m and n times (n included) and folds the list of return value</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.i16.html" title="nom::i16 macro">i16</a></div><div class="item-right docblock-short"><p>if parameter is true, parse a big endian i16 integer,
otherwise a little endian i16 integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.i32.html" title="nom::i32 macro">i32</a></div><div class="item-right docblock-short"><p>if parameter is true, parse a big endian i32 integer,
otherwise a little endian i32 integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.i64.html" title="nom::i64 macro">i64</a></div><div class="item-right docblock-short"><p>if parameter is true, parse a big endian i64 integer,
otherwise a little endian i64 integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.is_a.html" title="nom::is_a macro">is_a</a></div><div class="item-right docblock-short"><p><code>is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that appear in the provided array</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.is_a_s.html" title="nom::is_a_s macro">is_a_s</a></div><div class="item-right docblock-short"><p><code>is_a_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that appear in the provided array</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.is_not.html" title="nom::is_not macro">is_not</a></div><div class="item-right docblock-short"><p><code>is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that do not appear in the provided array</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.is_not_s.html" title="nom::is_not_s macro">is_not_s</a></div><div class="item-right docblock-short"><p><code>is_not_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that do not appear in the provided array</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.length_bytes.html" title="nom::length_bytes macro">length_bytes</a></div><div class="item-right docblock-short"><p>`length_bytes!(&amp;[T] -&gt; IResult&lt;&amp;[T], nb&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;
gets a number from the first parser, then extracts that many bytes from the
remaining stream</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.length_value.html" title="nom::length_value macro">length_value</a></div><div class="item-right docblock-short"><p><code>length_value!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
gets a number from the first parser, then applies the second parser that many times</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.many0.html" title="nom::many0 macro">many0</a></div><div class="item-right docblock-short"><p><code>many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 0 or more times and returns the list of results in a Vec</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.many1.html" title="nom::many1 macro">many1</a></div><div class="item-right docblock-short"><p><code>many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 1 or more times and returns the list of results in a Vec</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.many_m_n.html" title="nom::many_m_n macro">many_m_n</a></div><div class="item-right docblock-short"><p><code>many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser between m and n times (n included) and returns the list of results in a Vec</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.map.html" title="nom::map macro">map</a></div><div class="item-right docblock-short"><p><code>map!(I -&gt; IResult&lt;I,O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function on the result of a parser</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.map_opt.html" title="nom::map_opt macro">map_opt</a></div><div class="item-right docblock-short"><p><code>map_opt!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Option&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning an Option on the output of a parser</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.map_res.html" title="nom::map_res macro">map_res</a></div><div class="item-right docblock-short"><p><code>map_res!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning a Result on the output of a parser</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.method.html" title="nom::method macro">method</a></div><div class="item-right docblock-short"><p>Makes a method from a parser combination</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.named.html" title="nom::named macro">named</a></div><div class="item-right docblock-short"><p>Makes a function from a parser combination</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.none_of.html" title="nom::none_of macro">none_of</a></div><div class="item-right docblock-short"><p>matches anything but the provided characters</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.not.html" title="nom::not macro">not</a></div><div class="item-right docblock-short"><p><code>not!(I -&gt; IResult&lt;I,0&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result only if the embedded parser returns Error or Incomplete
does not consume the input</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.one_of.html" title="nom::one_of macro">one_of</a></div><div class="item-right docblock-short"><p>matches one of the provided characters</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.opt.html" title="nom::opt macro">opt</a></div><div class="item-right docblock-short"><p><code>opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
make the underlying parser optional</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.opt_res.html" title="nom::opt_res macro">opt_res</a></div><div class="item-right docblock-short"><p><code>opt_res!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Result&lt;nom::Err,O&gt;&gt;</code>
make the underlying parser optional</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.pair.html" title="nom::pair macro">pair</a></div><div class="item-right docblock-short"><p><code>pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
pair(X,Y), returns (x,y)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.peek.html" title="nom::peek macro">peek</a></div><div class="item-right docblock-short"><p><code>peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result without consuming the input</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.preceded.html" title="nom::preceded macro">preceded</a></div><div class="item-right docblock-short"><p><code>preceded!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
preceded(opening, X) returns X</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.recognize.html" title="nom::recognize macro">recognize</a></div><div class="item-right docblock-short"><p><code>recognize!(&amp;[T] -&gt; IResult&lt;&amp;[T], O&gt; ) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
if the child parser was successful, return the consumed input as produced value</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.separated_list.html" title="nom::separated_list macro">separated_list</a></div><div class="item-right docblock-short"><p><code>separated_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_list(sep, X) returns Vec<X></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.separated_nonempty_list.html" title="nom::separated_nonempty_list macro">separated_nonempty_list</a></div><div class="item-right docblock-short"><p><code>separated_nonempty_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_nonempty_list(sep, X) returns Vec<X></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.separated_pair.html" title="nom::separated_pair macro">separated_pair</a></div><div class="item-right docblock-short"><p><code>separated_pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I, T&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
separated_pair(X,sep,Y) returns (x,y)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.switch.html" title="nom::switch macro">switch</a></div><div class="item-right docblock-short"><p><code>switch!(I -&gt; IResult&lt;I,P&gt;, P =&gt; I -&gt; IResult&lt;I,O&gt; | ... | P =&gt; I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
choose the next parser depending on the result of the first one, if successful,
and returns the result of the second parser</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.tag.html" title="nom::tag macro">tag</a></div><div class="item-right docblock-short"><p><code>tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a byte array as a suite to recognize</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.tag_bits.html" title="nom::tag_bits macro">tag_bits</a></div><div class="item-right docblock-short"><p>matches an integer pattern to a bitstream. The number of bits of the input to compare must be specified</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.tag_s.html" title="nom::tag_s macro">tag_s</a></div><div class="item-right docblock-short"><p><code>tag_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a string as a suite to recognize</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take.html" title="nom::take macro">take</a></div><div class="item-right docblock-short"><p><code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming the specified number of bytes</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_bits.html" title="nom::take_bits macro">take_bits</a></div><div class="item-right docblock-short"><p><code>take_bits!(type, nb) =&gt; ( (&amp;[T], usize), U, usize) -&gt; IResult&lt;(&amp;[T], usize), U&gt;</code>
generates a parser consuming the specified number of bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_s.html" title="nom::take_s macro">take_s</a></div><div class="item-right docblock-short"><p><code>take_s!(nb) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming the specified number of characters</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_str.html" title="nom::take_str macro">take_str</a></div><div class="item-right docblock-short"><p><code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;</code>
same as take! but returning a &amp;str</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_till.html" title="nom::take_till macro">take_till</a></div><div class="item-right docblock-short"><p><code>take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function succeeds</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_till_s.html" title="nom::take_till_s macro">take_till_s</a></div><div class="item-right docblock-short"><p><code>take_till_s!(&amp;str -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function succeeds</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_until.html" title="nom::take_until macro">take_until</a></div><div class="item-right docblock-short"><p><code>take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds the specified tag</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_until_and_consume.html" title="nom::take_until_and_consume macro">take_until_and_consume</a></div><div class="item-right docblock-short"><p><code>take_until_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes until the specified byte sequence is found, and consumes it</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_until_and_consume_s.html" title="nom::take_until_and_consume_s macro">take_until_and_consume_s</a></div><div class="item-right docblock-short"><p><code>take_until_and_consume_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and consumes it</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_until_either.html" title="nom::take_until_either macro">take_until_either</a></div><div class="item-right docblock-short"><p><code>take_until_either!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_until_either_and_consume.html" title="nom::take_until_either_and_consume macro">take_until_either_and_consume</a></div><div class="item-right docblock-short"><p><code>take_until_either_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds any of the specified characters, and consume it</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_until_s.html" title="nom::take_until_s macro">take_until_s</a></div><div class="item-right docblock-short"><p><code>take_until_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and leaves it in the remaining input</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_while.html" title="nom::take_while macro">take_while</a></div><div class="item-right docblock-short"><p><code>take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function fails.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_while1.html" title="nom::take_while1 macro">take_while1</a></div><div class="item-right docblock-short"><p><code>take_while1!(&amp;[T] -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest (non empty) list of bytes until the provided function fails.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_while1_s.html" title="nom::take_while1_s macro">take_while1_s</a></div><div class="item-right docblock-short"><p><code>take_while1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest (non empty) list of characters until the provided function fails.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.take_while_s.html" title="nom::take_while_s macro">take_while_s</a></div><div class="item-right docblock-short"><p><code>take_while_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function fails.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.tap.html" title="nom::tap macro">tap</a></div><div class="item-right docblock-short"><p><code>tap!(name: I -&gt; IResult&lt;I,O&gt; =&gt; { block }) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
allows access to the parser’s result without affecting it</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.terminated.html" title="nom::terminated macro">terminated</a></div><div class="item-right docblock-short"><p><code>terminated!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,T&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
terminated(X, closing) returns X</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.try_parse.html" title="nom::try_parse macro">try_parse</a></div><div class="item-right docblock-short"><p>A bit like <code>std::try!</code>, this macro will return the remaining input and parsed value if the child parser returned <code>Done</code>,
and will do an early return for <code>Error</code> and <code>Incomplete</code>
this can provide more flexibility than <code>chain!</code> if needed</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.tuple.html" title="nom::tuple macro">tuple</a></div><div class="item-right docblock-short"><p><code>tuple!(I-&gt;IResult&lt;I,A&gt;, I-&gt;IResult&lt;I,B&gt;, ... I-&gt;IResult&lt;I,X&gt;) =&gt; I -&gt; IResult&lt;I, (A, B, ..., X)&gt;</code>
chains parsers and assemble the sub results in a tuple.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.u16.html" title="nom::u16 macro">u16</a></div><div class="item-right docblock-short"><p>if parameter is true, parse a big endian u16 integer,
otherwise a little endian u16 integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.u32.html" title="nom::u32 macro">u32</a></div><div class="item-right docblock-short"><p>if parameter is true, parse a big endian u32 integer,
otherwise a little endian u32 integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.u64.html" title="nom::u64 macro">u64</a></div><div class="item-right docblock-short"><p>if parameter is true, parse a big endian u64 integer,
otherwise a little endian u64 integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.value.html" title="nom::value macro">value</a></div><div class="item-right docblock-short"><p><code>value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ChainConsumer.html" title="nom::ChainConsumer struct">ChainConsumer</a></div><div class="item-right docblock-short"><p>ChainConsumer takes a consumer C1 R -&gt; S, and a consumer C2 S -&gt; T, and makes a consumer R -&gt; T by applying C2 on C1’s result</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.FileProducer.html" title="nom::FileProducer struct">FileProducer</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MapConsumer.html" title="nom::MapConsumer struct">MapConsumer</a></div><div class="item-right docblock-short"><p>MapConsumer takes a function S -&gt; T and applies it on a consumer producing values of type S</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MemProducer.html" title="nom::MemProducer struct">MemProducer</a></div><div class="item-right docblock-short"><p>A MemProducer generates values from an in memory byte buffer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ProducerRepeat.html" title="nom::ProducerRepeat struct">ProducerRepeat</a></div><div class="item-right docblock-short"><p>ProducerRepeat takes a single value, and generates it at each step</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ConsumerState.html" title="nom::ConsumerState enum">ConsumerState</a></div><div class="item-right docblock-short"><p>Stores a consumer’s current computation state</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Err.html" title="nom::Err enum">Err</a></div><div class="item-right docblock-short"><p>Contains the error that a parser can return</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ErrorKind.html" title="nom::ErrorKind enum">ErrorKind</a></div><div class="item-right docblock-short"><p>indicates which parser returned an error</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.FileProducerState.html" title="nom::FileProducerState enum">FileProducerState</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.IResult.html" title="nom::IResult enum">IResult</a></div><div class="item-right docblock-short"><p>Holds the result of parsing functions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Input.html" title="nom::Input enum">Input</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Move.html" title="nom::Move enum">Move</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Needed.html" title="nom::Needed enum">Needed</a></div><div class="item-right docblock-short"><p>Contains information on needed data if a parser returned <code>Incomplete</code></p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.AsBytes.html" title="nom::AsBytes trait">AsBytes</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.AsChar.html" title="nom::AsChar trait">AsChar</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Consumer.html" title="nom::Consumer trait">Consumer</a></div><div class="item-right docblock-short"><p>The Consumer trait wraps a computation and its state</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.GetInput.html" title="nom::GetInput trait">GetInput</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.GetOutput.html" title="nom::GetOutput trait">GetOutput</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.HexDisplay.html" title="nom::HexDisplay trait">HexDisplay</a></div><div class="item-right docblock-short"><p>useful functions to calculate the offset between slices and show a hexdump of a slice</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.InputLength.html" title="nom::InputLength trait">InputLength</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IterIndices.html" title="nom::IterIndices trait">IterIndices</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Producer.html" title="nom::Producer trait">Producer</a></div><div class="item-right docblock-short"><p>The producer wraps a data source, like file or network, and applies a consumer on it</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_error_pattern.html" title="nom::add_error_pattern fn">add_error_pattern</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.alpha.html" title="nom::alpha fn">alpha</a></div><div class="item-right docblock-short"><p>Recognizes lowercase and uppercase alphabetic characters: a-zA-Z</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.alphanumeric.html" title="nom::alphanumeric fn">alphanumeric</a></div><div class="item-right docblock-short"><p>Recognizes numerical and alphabetic characters: 0-9a-zA-Z</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.anychar.html" title="nom::anychar fn">anychar</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.be_f32.html" title="nom::be_f32 fn">be_f32</a></div><div class="item-right docblock-short"><p>Recognizes big endian 4 bytes floating point number</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.be_f64.html" title="nom::be_f64 fn">be_f64</a></div><div class="item-right docblock-short"><p>Recognizes big endian 8 bytes floating point number</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.be_i8.html" title="nom::be_i8 fn">be_i8</a></div><div class="item-right docblock-short"><p>Recognizes a signed 1 byte integer (equivalent to take!(1)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.be_i16.html" title="nom::be_i16 fn">be_i16</a></div><div class="item-right docblock-short"><p>Recognizes big endian signed 2 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.be_i32.html" title="nom::be_i32 fn">be_i32</a></div><div class="item-right docblock-short"><p>Recognizes big endian signed 4 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.be_i64.html" title="nom::be_i64 fn">be_i64</a></div><div class="item-right docblock-short"><p>Recognizes big endian signed 8 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.be_u8.html" title="nom::be_u8 fn">be_u8</a></div><div class="item-right docblock-short"><p>Recognizes an unsigned 1 byte integer (equivalent to take!(1)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.be_u16.html" title="nom::be_u16 fn">be_u16</a></div><div class="item-right docblock-short"><p>Recognizes big endian unsigned 2 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.be_u32.html" title="nom::be_u32 fn">be_u32</a></div><div class="item-right docblock-short"><p>Recognizes big endian unsigned 4 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.be_u64.html" title="nom::be_u64 fn">be_u64</a></div><div class="item-right docblock-short"><p>Recognizes big endian unsigned 8 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.begin.html" title="nom::begin fn">begin</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.code_from_offset.html" title="nom::code_from_offset fn">code_from_offset</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.compare_error_paths.html" title="nom::compare_error_paths fn">compare_error_paths</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.crlf.html" title="nom::crlf fn">crlf</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.digit.html" title="nom::digit fn">digit</a></div><div class="item-right docblock-short"><p>Recognizes numerical characters: 0-9</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.eof.html" title="nom::eof fn">eof</a></div><div class="item-right docblock-short"><p>Recognizes empty input buffers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.eol.html" title="nom::eol fn">eol</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.error_to_list.html" title="nom::error_to_list fn">error_to_list</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.error_to_u32.html" title="nom::error_to_u32 fn">error_to_u32</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.generate_colors.html" title="nom::generate_colors fn">generate_colors</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.hex_digit.html" title="nom::hex_digit fn">hex_digit</a></div><div class="item-right docblock-short"><p>Recognizes hexadecimal numerical characters: 0-9, A-F, a-f</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.hex_u32.html" title="nom::hex_u32 fn">hex_u32</a></div><div class="item-right docblock-short"><p>Recognizes a hex-encoded integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_alphabetic.html" title="nom::is_alphabetic fn">is_alphabetic</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_alphanumeric.html" title="nom::is_alphanumeric fn">is_alphanumeric</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_digit.html" title="nom::is_digit fn">is_digit</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_hex_digit.html" title="nom::is_hex_digit fn">is_hex_digit</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_oct_digit.html" title="nom::is_oct_digit fn">is_oct_digit</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_space.html" title="nom::is_space fn">is_space</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.le_f32.html" title="nom::le_f32 fn">le_f32</a></div><div class="item-right docblock-short"><p>Recognizes little endian 4 bytes floating point number</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.le_f64.html" title="nom::le_f64 fn">le_f64</a></div><div class="item-right docblock-short"><p>Recognizes little endian 8 bytes floating point number</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.le_i8.html" title="nom::le_i8 fn">le_i8</a></div><div class="item-right docblock-short"><p>Recognizes a signed 1 byte integer (equivalent to take!(1)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.le_i16.html" title="nom::le_i16 fn">le_i16</a></div><div class="item-right docblock-short"><p>Recognizes little endian signed 2 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.le_i32.html" title="nom::le_i32 fn">le_i32</a></div><div class="item-right docblock-short"><p>Recognizes little endian signed 4 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.le_i64.html" title="nom::le_i64 fn">le_i64</a></div><div class="item-right docblock-short"><p>Recognizes little endian signed 8 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.le_u8.html" title="nom::le_u8 fn">le_u8</a></div><div class="item-right docblock-short"><p>Recognizes an unsigned 1 byte integer (equivalent to take!(1)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.le_u16.html" title="nom::le_u16 fn">le_u16</a></div><div class="item-right docblock-short"><p>Recognizes little endian unsigned 2 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.le_u32.html" title="nom::le_u32 fn">le_u32</a></div><div class="item-right docblock-short"><p>Recognizes little endian unsigned 4 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.le_u64.html" title="nom::le_u64 fn">le_u64</a></div><div class="item-right docblock-short"><p>Recognizes little endian unsigned 8 bytes integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.length_value.html" title="nom::length_value fn">length_value</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.line_ending.html" title="nom::line_ending fn">line_ending</a></div><div class="item-right docblock-short"><p>Recognizes a line feed</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.multispace.html" title="nom::multispace fn">multispace</a></div><div class="item-right docblock-short"><p>Recognizes spaces, tabs, carriage returns and line feeds</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.newline.html" title="nom::newline fn">newline</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.non_empty.html" title="nom::non_empty fn">non_empty</a></div><div class="item-right docblock-short"><p>Recognizes non empty buffers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.not_line_ending.html" title="nom::not_line_ending fn">not_line_ending</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.oct_digit.html" title="nom::oct_digit fn">oct_digit</a></div><div class="item-right docblock-short"><p>Recognizes octal characters: 0-7</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.prepare_errors.html" title="nom::prepare_errors fn">prepare_errors</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.print.html" title="nom::print fn">print</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.print_codes.html" title="nom::print_codes fn">print_codes</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.print_error.html" title="nom::print_error fn">print_error</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.print_offsets.html" title="nom::print_offsets fn">print_offsets</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.reset_color.html" title="nom::reset_color fn">reset_color</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.rest.html" title="nom::rest fn">rest</a></div><div class="item-right docblock-short"><p>Return the remaining input.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.rest_s.html" title="nom::rest_s fn">rest_s</a></div><div class="item-right docblock-short"><p>Return the remaining input, for strings.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.shift.html" title="nom::shift fn">shift</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.sized_buffer.html" title="nom::sized_buffer fn">sized_buffer</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.slice_to_offsets.html" title="nom::slice_to_offsets fn">slice_to_offsets</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.space.html" title="nom::space fn">space</a></div><div class="item-right docblock-short"><p>Recognizes spaces and tabs</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.tab.html" title="nom::tab fn">tab</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.tag_cl.html" title="nom::tag_cl fn">tag_cl</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.write_color.html" title="nom::write_color fn">write_color</a></div><div class="item-right docblock-short"></div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="nom" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>